---
title: "Vignette Title"
author: "Vignette Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(ggplot2)
library(ggfun)
library(dplyr)
```

Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format:

- Never uses retina figures
- Has a smaller default figure size
- Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style

## Vignette Info

Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))


# Yawei Part

## stat_star()

This function is a simple application of `ggplot2` extension functionlity in `stat` function. We provided an algorithm here to calculate the "distance" between points and the central point (defined by median) ginven a data set for scatter plot. And draw a line from the central point to the farthest point. It works with usual `line` geometry objects and applies our algorithm as `stat`.

The following two examples show the usage in a skewed distribution and a bell-shaped distribution.

```{r}
madedata1 <- data.frame(x = rnorm(n = 100, mean = 0, sd = 1), 
                        y = rf(n = 100, df1 = 5, df2 = 2))
madedata2 <- data.frame(x = rnorm(n = 100, mean = 0, sd = 1), 
                        y = rnorm(n = 100, mean = 0, sd = 1))

ggplot(madedata1, aes(x = x, y = y)) + 
  geom_point() + 
  stat_star()

ggplot(madedata2, aes(x = x, y = y)) + 
  geom_point() + 
  stat_star()
```

## stat_arrowmap()

This function follows the same logic from the above function. They both create new algorithms for certain purposes and make use of the existing geometry objects in `ggplot2`. This function is less general and focuses on a very specific goal that is to create a so called arrow map for the US elections. So it requires the US map information and a data set containing some elements needed to show here.

So usually before you can directly using this function, you need to organize your data into a required form. The required aesthetics are:

- `x`: usually longitude
- `y`: usually latitude
- `change`: the changes for each state (can be specified by group aesthetics, as one state by default).

Here we use a made up data set to illustrate the main usage of the function.

```{r fig.width=5}
usmap <- map_data("state")
madedata <- data.frame(region = unique(usmap$region), 
                                change = (runif(49)-0.5)*2,stringsAsFactors = FALSE)
madedata <- madedata %>%
  left_join(usmap,by = "region")

madedata %>%
  ggplot() +
  geom_path(aes(x = long, y = lat, group = group)) +
  stat_arrowmap(aes(x = long, y = lat, change = change, group = region))
```

This is not a good picture, however, notice that we can use the parameters in `geom_curve` here to modify the arrows to make them better since this function use the `curve` geometry object.

```{r fig.width=5}
madedata %>%
  ggplot() +
  geom_path(aes(x = long, y = lat, group = group)) +
  stat_arrowmap(aes(x = long, y = lat, change = change, group = region),
                curvature = 0.3, angle = 60,
                size = 1, arrow.fill = "yellow", 
                arrow = arrow(angle = 25,
                              type = "closed",
                              length = unit(0.1, "inches")))
```

## geom_image()

This function replaces the usual points object in `ggplot2` with provied image. This is different from the previous `stat` related functions, because it create a new geometry object instead of using the existing one. You can treat it like `geom_point` with the points replaced by your image.

Examples are shown below.

```{r , fig.width=5, fig.height=4}
path1 <- system.file("extdata", "donkey.jpg", package = "ggfun")
path2 <- system.file("extdata", "elephant.jpg", package = "ggfun")
p1 <- magick::image_read(path1)
p2 <- magick::image_read(path2)

mtcars %>%
  ggplot() + 
  geom_image(aes(x = wt, y = mpg), img = p1)

mtcars %>%
  ggplot() + 
  geom_image(aes(x = qsec, y = mpg), img = p2, size = 0.1)
```

# Zhenzhen Part


# Weiquan Part

## layer_PersHomo()

Given a points set as Geographic locations in a data.frame, extends ggplot2 functionality to draw a line from location to location with defined criterion of distance in km. The concept is inhered from persist homology. The linkage in resulting figures can be used to recognize patterns or cluster of points.Compare to ggplot2 package, plotly package might be better for this functionality because the linkage can be shown on the globe instead of a flat figure. To the purpose of the package, this layer attempt to show the capability of ggplot on a small scale data instead of global data.


The required input are:

- `data`: a dataframe that each row contain longitude, latitude. 
- `x`: longitude in the input dataframe.
- `y`: latitude in the input dataframe.
- `d`: the magnitude of real Geo distance (in km) used as the criterion to link two locations.

The following example show the earthquake data with in Pacific Plate

```{r}
library(magrittr)
library(ggplot2)
library(dplyr)
## plot base map
worldmap <- map_data("world2")
p <- ggplot() +
  geom_polygon(data=worldmap,
  aes(x=long, y=lat, group = group),
  fill="white", colour="#7f7f7f", size=0.5) +
  theme(axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        legend.position="none",
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank());
data(eqRaw)
eq <- eqRaw %>%
  filter(LONGITUDE > 110 | LONGITUDE < -45) %>%
  mutate(LONGITUDE = ifelse(LONGITUDE < 0, LONGITUDE + 360, LONGITUDE))
## add layer_PersHomo
fp <- p + layer_PersHomo(data= eq,mapping = aes(x=LONGITUDE, y=LATITUDE),
  d=450000, colour = "blue") + geom_point(); fp
```

